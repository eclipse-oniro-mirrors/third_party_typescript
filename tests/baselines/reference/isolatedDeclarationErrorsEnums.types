=== tests/cases/compiler/isolatedDeclarationErrorsEnums.ts ===
declare function computed(x: number): number;
>computed : (x: number) => number
>x : number

enum E {
>E : E

    A = computed(0),
>A : E
>computed(0) : number
>computed : (x: number) => number
>0 : 0

    B = computed(1),
>B : E
>computed(1) : number
>computed : (x: number) => number
>1 : 1

    C = computed(2),
>C : E
>computed(2) : number
>computed : (x: number) => number
>2 : 2

    D = computed(3),
>D : E
>computed(3) : number
>computed : (x: number) => number
>3 : 3
}


enum F {
>F : F

    A = E.A,
>A : F
>E.A : E
>E : typeof E
>A : E

    B = A,
>B : F
>A : F
}


enum Flag {
>Flag : Flag

    A = 1 >> 1,
>A : Flag
>1 >> 1 : number
>1 : 1
>1 : 1

    B = 2 >> 2,
>B : Flag
>2 >> 2 : number
>2 : 2
>2 : 2

    C = 3 >> 2,
>C : Flag
>3 >> 2 : number
>3 : 3
>2 : 2

    AB = A | B,
>AB : Flag
>A | B : number
>A : Flag
>B : Flag

    ABC = Flag.AB | C,
>ABC : Flag
>Flag.AB | C : number
>Flag.AB : Flag
>Flag : typeof Flag
>AB : Flag
>C : Flag

    AC = Flag["A"] | C,
>AC : Flag
>Flag["A"] | C : number
>Flag["A"] : Flag
>Flag : typeof Flag
>"A" : "A"
>C : Flag
}

const EV = 1;
>EV : 1
>1 : 1

enum ExtFlags {
>ExtFlags : ExtFlags

    D = 4 >> 1,
>D : ExtFlags
>4 >> 1 : number
>4 : 4
>1 : 1

    E = EV,
>E : ExtFlags
>EV : 1

    ABCD = Flag.ABC | D,
>ABCD : ExtFlags
>Flag.ABC | D : number
>Flag.ABC : Flag
>Flag : typeof Flag
>ABC : Flag
>D : ExtFlags

    AC = Flag["A"] | D,
>AC : ExtFlags
>Flag["A"] | D : number
>Flag["A"] : Flag
>Flag : typeof Flag
>"A" : "A"
>D : ExtFlags
}


enum Str {
>Str : Str

    A = "A",
>A : Str.A
>"A" : "A"

    B = "B",
>B : Str.B
>"B" : "B"

    AB = A + B
>AB : Str.AB
>A + B : string
>A : Str.A
>B : Str.B
}


enum StrExt {
>StrExt : StrExt

    D = "D",
>D : StrExt.D
>"D" : "D"

    ABD = Str.AB + D,
>ABD : StrExt.ABD
>Str.AB + D : string
>Str.AB : Str.AB
>Str : typeof Str
>AB : Str.AB
>D : StrExt.D

    AD = Str["A"] + D,
>AD : StrExt.ABD
>Str["A"] + D : string
>Str["A"] : Str.A
>Str : typeof Str
>"A" : "A"
>D : StrExt.D
}
